Билет 27.
-----ЗАДАНИЕ 1------
Перечисления.
Синтаксис и применение.
Перечисления в switch.
Перечисления в аннотациях.
--------------------

Тип enum — это специальный тип данных, который позволяет переменной быть набором предопределенных констант. Другими словами, он позволяет создать переменную, которая может принимать несколько значений (каждое из значений, объявленных в самом перечислении, и ничего более).
Все константы, определенные в перечислении, являются public static final. Поскольку они статичны, доступ к ним можно получить через EnumName.instanceName;
Пример использования:
public enum Size {
	SMALL,
	MEDIUM,
	LARGE
}

Size size = Size.SMALL;


Методы enum’а
Тип enum имеет несколько встроенных методов, два из них очень интересные:

Статический метод values() возвращает массив всех значений типа enum
Метод ordinal() возвращает порядковый номер константы. Вызывать его нужно не у класса enum, а у значения enum
Чтобы преобразовать объект типа enum в строку, у него нужно вызвать метод toString()
Для обратного преобразования (строки в объект Day) можно воспользоваться статическим методом valueOf()



оператор switch. Его еще называют оператором множественного выбора. Выглядит он немного громоздко:

switch(выражение)
{
   case значение1: код1;
   case значение2: код2;
   case значение3: код3;
}
Внутри скобок указывается какое-нибудь выражение или переменная. Если значение выражений равно значение1, начинает выполняться код1, если равно значение2, начинает выполняться код2, если равно значение3 начинает выполняться код3.


Не все типы можно использовать в качестве значений для case внутри оператора switch. Сейчас там можно использовать литералы таких типов:

целые типы: byte, short, int
тип char
тип String
значения любого enum-типа
Никаких других типов писать в качестве значений внутри case нельзя.




..............это тут было......звучит полезно, хоть и не по теме
Исключительная ситуация – это событие, которое привело к сбою в работе программы.
        Object
           |
     Throwable(CHECKED)
      /            \
Error(UNCHECKED)  Exception(CHECKED)
                      |
                   RuntimeException(UNCHECKED)

Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked
— Error и RuntimeException и все их наследники — unchecked
Необходимо понимать, что
— проверка на checked исключения происходит в момент компиляции (compile-time checking)
— перехват исключений (catch) происходит в момент выполнения (runtime checking)

Механизм обработки: В Java исключения обрабатываются с помощью конструкции try-catch-finally, где finally – опциональная ветка, при наличии выполняется как после try, так и любой из веток catch. Кроме того, часто исключения не перехватываются в том методе, где возникают, а пробрасываются выше по стеку вызовов.
Классификация исключений: Все исключения делятся на 2 вида — проверяемые (checked) и непроверяемые (unchecked). 
Все проверяемые исключения (checked) происходят от класса Exception.
Второй вид исключений — “непроверяемые”. Они происходят от классов RuntimeException, Error. Этих ошибок компилятор не ожидает.  
Генерация исключений: Генерация (порождение) исключения происходит по ключевому слову throw, которое употребляется либо с параметром, либо без него:
throw [ <выражение> ];
Тип выражения, стоящего после throw, определяет тип порождаемого исключения. При генерации исключения выполнение текущего блока прекращается, и происходит поиск соответствующего обработчика и передача ему управления. Как правило, исключение генерируется не в try-блоке, а в функциях, прямо или косвенно в него вложенных.



-----ЗАДАНИЕ 2------
Работа с файлами в Java.
Примеры использования.
--------------------

Чтобы работать с файлами, есть шикарный утилитный класс — java.nio.file.Files. У него есть методы просто на все случаи жизни. Все методы этого класса статические и работают с объектами типа Path. Методов очень много, поэтому мы рассмотрим только основные:

Path createFile(Path path) Создает новый файл с путем path
Path createDirectory(Path path) Создает новую директорию
Path createDirectories(Path path) Создает несколько директорий
Path createTempFile(prefix, suffix) Создает временный файл
Path createTempDirectory(prefix) Создает временную директорию
void delete(Path path) Удаляет файл или директорию, если она пуста
Path copy(Path src, Path dest) Копирует файл
Path move(Path src, Path dest) Перемещает файл
boolean isDirectory(Path path) Проверяет, что путь — это директория, а не файл
boolean isRegularFile(Path path) Проверяет, что путь — это файл, а не директория
boolean exists(Path path)Проверяет, что объект по заданному пути существует
long size(Path path) Возвращает размер файла
byte[] readAllBytes(Path path) Возвращает все содержимое файла в виде массива байт
String readString(Path path) Возвращает все содержимое файла в виде строки
List<String> readAllLines(Path path) Возвращает все содержимое файла в виде списка строк
Path write(Path path, byte[]) Записывает в файл массив байт
Path writeString(Path path, String str) Записывает в файл строку
DirectoryStream<Path> newDirectoryStream(Path dir) Возвращает коллекцию файлов (и поддиректорий) из заданной директории





Класс File, определенный в пакете java.io, не работает напрямую с потоками. Его задачей является управление информацией о файлах и каталогах.
Хотя на уровне операционной системы файлы и каталоги отличаются, но в Java они описываются одним классом File.

В зависимости от того, что должен представлять объект File - файл или каталог, мы можем использовать один из конструкторов для создания объекта:
Например:
// создаем объект File для каталога
File dir1 = new File("C://SomeDir");
// создаем объекты для файлов, которые находятся в каталоге
File file1 = new File("C://SomeDir", "Hello.txt");
File file2 = new File(dir1, "Hello2.txt");

Класс File имеет ряд методов, которые позволяют управлять файлами и каталогами. Рассмотрим некоторые из них:
boolean createNewFile(): создает новый файл по пути, который передан в конструктор. В случае удачного создания возвращает true, иначе false
boolean delete(): удаляет каталог или файл по пути, который передан в конструктор. При удачном удалении возвращает true.
boolean exists(): проверяет, существует ли по указанному в конструкторе пути файл или каталог. И если файл или каталог существует, то возвращает true, иначе возвращает false
String getAbsolutePath(): возвращает абсолютный путь для пути, переданного в конструктор объекта
String getName(): возвращает краткое имя файла или каталога
String getParent(): возвращает имя родительского каталога
boolean isDirectory(): возвращает значение true, если по указанному пути располагается каталог
boolean isFile(): возвращает значение true, если по указанному пути находится файл
boolean isHidden(): возвращает значение true, если каталог или файл являются скрытыми
long length(): возвращает размер файла в байтах
long lastModified(): возвращает время последнего изменения файла или каталога. Значение представляет количество миллисекунд, прошедших с начала эпохи Unix
String[] list(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
File[] listFiles(): возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
boolean mkdir(): создает новый каталог и при удачном создании возвращает значение true
boolean renameTo(File dest): переименовывает файл или каталог

